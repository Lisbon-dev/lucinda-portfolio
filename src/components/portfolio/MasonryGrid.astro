---
// MasonryGrid.astro - Responsive masonry grid component using Macy.js
// Based on Task #23 requirements and TASK_007_#23_CLARIFICATIONS.md

import { Image } from 'astro:assets';
import type { CollectionEntry } from 'astro:content';

export interface Props {
  projects: CollectionEntry<'projects'>[];
  className?: string;
}

const { projects = [], className = '' } = Astro.props;
---

<div class={`masonry-container ${className}`}>
  <div id="masonry-grid" class="masonry-grid">
    {projects.flatMap((project, index) => 
        <div class="masonry-item" data-project={project.slug} data-image={index}>
          <a href={`/projects/${project.slug}`} class="project-link" aria-label={`View ${project.data.title} project`}>
            <div class="image-container">
              <Image 
                src={project.data.mainImage.src}
                alt={project.data.mainImage.alt}
                class="masonry-image"
                width={project.data.mainImage.width || 800}
                height={project.data.mainImage.height || 600}
                format="webp"
                quality={85}
                loading={index < 4 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index < 2 ? "high" : "low"}
                densities={[1, 1.5, 2]}
              />
              <div class="overlay">
                <div class="overlay-content">
                  <h3 class="project-title">{project.data.title}</h3>
                  <p class="project-category">{project.data.category}</p>
                </div>
              </div>
            </div>
          </a>
        </div>
      ) || []
    }
  </div>
</div>

<!-- Macy.js CDN -->
<script is:inline src="https://cdn.jsdelivr.net/npm/macy@2"></script>

<script>
  // Declare global types for TypeScript
  declare global {
    interface Window {
      Macy: any;
    }
  }

  // Initialize Macy.js masonry grid
  document.addEventListener('DOMContentLoaded', () => {
    const masonryContainer = document.getElementById('masonry-grid');
    
    if (masonryContainer && window.Macy) {
      let resizeTimeout: number;

      // Initialize Macy.js with responsive breakpoint configuration
      const macyInstance = new window.Macy({
        container: '#masonry-grid',
        trueOrder: false,
        waitForImages: true,
        useOwnImageLoader: false,
        mobileFirst: true,
        columns: 1,
        margin: {
          y: 24,
          x: '3%'
        },
        breakAt: {
          1600: {  // 4 columns for >1600px (matches design system --breakpoint-2xl)
            columns: 4,
            margin: { y: 66, x: '2.5%' }
          },
          768: {   // 3 columns for 768-1600px (matches design system --breakpoint-md)
            columns: 3,
            margin: { y: 66, x: '3%' }
          },
          550: {   // 2 columns for 550-768px (matches design system --breakpoint-base)
            columns: 2,
            margin: { y: 24, x: '3%' }
          }
          // 1 column for <550px (mobile-first default)
        }
      });

      // Handle image loading with fade-in animation
      macyInstance.runOnImageLoad(function() {
        // Recalculate layout after images load
        macyInstance.recalculate(true);
      }, true);

      // Enhanced staggered animation for masonry items
      const animateItems = () => {
        const items = masonryContainer.querySelectorAll('.masonry-item');
        items.forEach((item, index) => {
          setTimeout(() => {
            item.classList.add('animated');
          }, index * 100); // Stagger by 100ms for smooth cascade effect
        });
      };

      // Enhanced Intersection Observer for advanced lazy loading and performance
      if ('IntersectionObserver' in window) {
        let ticking = false;
        
        const imageObserver = new IntersectionObserver((entries) => {
          if (!ticking) {
            requestAnimationFrame(() => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  const item = entry.target;
                  const img = item.querySelector('.masonry-image');
                  const container = item.querySelector('.image-container');
                  
                  // Progressive loading with performance optimizations
                  if (img && container) {
                    // Upgrade image importance when in viewport
                    img.setAttribute('fetchpriority', 'high');
                    (img as HTMLElement).style.contentVisibility = 'visible';
                    
                    // Add loading state
                    container.classList.add('loading');
                    
                    // Mark as visible for animations
                    item.classList.add('visible');
                    
                    // Stop observing this image
                    imageObserver.unobserve(item);
                  }
                }
              });
              ticking = false;
            });
            ticking = true;
          }
        }, { 
          rootMargin: '100px 0px', // Start loading 100px before viewport
          threshold: [0, 0.25, 0.5, 0.75, 1] // Multiple thresholds for progressive loading
        });

        // Memory management observer for large grids
        const memoryObserver = new IntersectionObserver((entries) => {
          entries.forEach(entry => {
            const item = entry.target;
            const img = item.querySelector('.masonry-image');
            
            if (!entry.isIntersecting && img) {
              // Unload images far from viewport to save memory
              const rect = item.getBoundingClientRect();
              if (Math.abs(rect.top) > window.innerHeight * 3) {
                (img as HTMLElement).style.contentVisibility = 'auto';
              }
            }
          });
        }, {
          rootMargin: '300% 0px' // Very large margin for memory management
        });

        // Observe all masonry items
        const items = masonryContainer.querySelectorAll('.masonry-item');
        items.forEach(item => {
          imageObserver.observe(item);
          memoryObserver.observe(item);
        });
      }

      // Handle resize events
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = window.setTimeout(() => {
          macyInstance.recalculate(true, true);
        }, 250);
      });

      // Enhanced focus management for accessibility
      const handleFocus = (event: FocusEvent) => {
        const focusedItem = (event.target as Element).closest('.masonry-item');
        if (focusedItem && !focusedItem.querySelector('img[src]')) {
          // Ensure focusable elements have their images loaded immediately
          const img = focusedItem.querySelector('.masonry-image') as HTMLImageElement;
          const container = focusedItem.querySelector('.image-container');
          if (img && container) {
            img.setAttribute('fetchpriority', 'high');
            container.classList.add('loading');
          }
        }
      };

      // Add focus event listener for accessibility
      masonryContainer.addEventListener('focusin', handleFocus);

      // Performance monitoring for Task-011 optimization
      let imageLoadCount = 0;
      const totalImages = masonryContainer.querySelectorAll('.masonry-image').length;
      
      masonryContainer.addEventListener('load', (event) => {
        if (event.target && (event.target as HTMLElement).classList.contains('masonry-image')) {
          imageLoadCount++;
          console.log(`Image loaded: ${imageLoadCount}/${totalImages}`);
          
          if (imageLoadCount === totalImages) {
            console.log('All masonry images loaded at:', performance.now(), 'ms');
          }
        }
      }, true);

      // Add loaded class to trigger CSS animations
      // Use EVENT_RECALCULATED instead of EVENT_INITIALIZED because:
      // EVENT_INITIALIZED fires immediately when instance is created, before layout
      // EVENT_RECALCULATED fires after layout calculations are complete
      macyInstance.on(macyInstance.constants.EVENT_RECALCULATED, () => {
        if (!masonryContainer.classList.contains('masonry-initialized')) {
          masonryContainer.classList.add('masonry-initialized');
          // Start staggered animations after layout is complete
          setTimeout(() => {
            animateItems();
          }, 200);
        }
      });
    }
  });
</script>

<style>
  .masonry-container {
    width: 100%;
    margin: 0 auto;
    padding: 0 var(--spacing-container-mobile);
  }

  @media (min-width: 768px) {
    .masonry-container {
      padding: 0 var(--spacing-container-tablet);
    }
  }

  @media (min-width: 1200px) {
    .masonry-container {
      padding: 0 var(--spacing-container-desktop);
    }
  }

  .masonry-grid {
    /* Macy.js will manage the grid layout */
    opacity: 0;
    transition: opacity var(--transition-normal);
  }


  .masonry-grid.masonry-initialized {
    opacity: 1;
  }


  .masonry-item {
    width: 100%;
    margin-bottom: 0; /* Macy.js handles margins internally */
    opacity: 0;
    transform: translateY(30px) scale(0.95);
    transition: 
      opacity 0.6s cubic-bezier(0.4, 0.0, 0.2, 1),
      transform 0.6s cubic-bezier(0.4, 0.0, 0.2, 1),
      box-shadow var(--transition-normal);
    will-change: opacity, transform;
    
    /* Performance optimizations */
    content-visibility: auto;
    contain-intrinsic-size: 300px 400px; /* Estimated size for layout stability */
    contain: layout style;
  }

  /* Fade in animation for items */
  .masonry-initialized .masonry-item {
    opacity: 1;
    transform: translateY(0) scale(1);
  }

  /* Enhanced visibility animation */
  .masonry-item.visible {
    opacity: 1;
    transform: translateY(0) scale(1);
  }

  .masonry-item.animated {
    opacity: 1;
    transform: translateY(0) scale(1);
  }

  .project-link {
    display: block;
    text-decoration: none;
    color: inherit;
    width: 100%;
    height: 100%;
  }

  .image-container {
    position: relative;
    overflow: hidden;
    border-radius: 0; /* Clean, minimal aesthetic */
    cursor: pointer;
    background-color: var(--color-surface);
  }

  .masonry-image {
    width: 100%;
    height: auto;
    display: block;
    transition: transform var(--transition-normal);
    
    /* Performance and loading optimizations */
    content-visibility: auto;
    background-color: var(--color-surface);
    aspect-ratio: attr(width) / attr(height); /* Maintain aspect ratio during loading */
  }

  .masonry-image-picture {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Loading state styling */
  .image-container.loading .masonry-image {
    background: linear-gradient(90deg, var(--color-surface) 25%, rgba(255,255,255,0.3) 50%, var(--color-surface) 75%);
    background-size: 200% 100%;
    animation: loading-shimmer 1.5s infinite;
  }

  @keyframes loading-shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Stop shimmer when image loads */
  .image-container.loading .masonry-image[src] {
    animation: none;
    background: none;
  }

  /* Hover effects - only on non-touch devices */
  @media (hover: hover) and (pointer: fine) {
    .masonry-item:hover {
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    }

    .masonry-item:hover .masonry-image {
      transform: scale(1.03);
    }

    .masonry-item:hover .overlay {
      opacity: 1;
      visibility: visible;
    }
  }

  /* Touch devices - show overlay on tap */
  @media (hover: none) and (pointer: coarse) {
    .masonry-item:active .overlay {
      opacity: 1;
      visibility: visible;
    }
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--color-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: 
      opacity var(--transition-normal),
      visibility var(--transition-normal);
  }

  .overlay-content {
    text-align: center;
    padding: var(--spacing-md);
    color: white;
  }

  .project-title {
    font-family: var(--font-alt-heading);
    font-size: var(--text-lg);
    font-weight: 400;
    line-height: var(--leading-tight);
    margin-bottom: var(--spacing-xs);
    letter-spacing: var(--tracking-wide);
  }

  .project-category {
    font-family: var(--font-alt-heading);
    font-size: var(--text-sm);
    font-weight: 300;
    letter-spacing: var(--tracking-wider);
    opacity: 0.9;
    margin: 0;
  }

  /* Mobile spacing adjustments */
  @media (max-width: 549px) {
    .masonry-container {
      padding: 0 var(--spacing-container-mobile);
    }
  }

  /* Focus management for accessibility */
  .masonry-item:focus-within {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  .project-link:focus {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  .project-link:focus .overlay {
    opacity: 1;
    visibility: visible;
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .masonry-item {
      animation: none !important;
      transition: none !important;
      will-change: auto;
    }

    .masonry-grid {
      transition: none !important;
    }

    .image-container.loading .masonry-image {
      animation: none !important;
      background: var(--color-surface) !important;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .masonry-item {
      border: 2px solid ButtonText;
    }
    
    .overlay {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid ButtonText;
    }
  }

  /* Performance optimizations for large screens */
  @media (min-width: 1600px) {
    .masonry-item {
      contain-intrinsic-size: 382px 500px; /* Larger estimated size for desktop */
    }
  }
</style>