---
// MasonryGrid.astro - Astro-native masonry grid with Motion.js animations
// Optimized for performance with fixed order and smooth animations

import { Picture } from 'astro:assets';
import { Masonry } from 'astro-masonry';
import type { CollectionEntry } from 'astro:content';

export interface Props {
  projects: CollectionEntry<'projects'>[];
  className?: string;
}

const { projects = [], className = '' } = Astro.props;

// Generate unique ID for this masonry instance
const uniqueId = `masonry-${Math.random().toString(36).substr(2, 9)}`;

// Sort projects for fixed, consistent order (by order, then date)
const sortedProjects = projects.sort((a, b) => {
  // Primary sort by order property (lower numbers first)
  const orderA = a.data.order || 999;
  const orderB = b.data.order || 999;
  if (orderA !== orderB) return orderA - orderB;
  
  // Fallback to date (newest first)
  const dateA = new Date(a.data.publishedDate || 0);
  const dateB = new Date(b.data.publishedDate || 0);
  return dateB.getTime() - dateA.getTime();
});

// To create anchor links for categories
const processedCategories = new Set();

---

<div class={`masonry-container ${className}`} id={uniqueId}>
  <Masonry 
    breakpointCols={{
      default: 3,
      767: 2,
      500: 1
    }}
  >
    {sortedProjects.map((project, index) => {
        const categorySlug = project.data.category.toLowerCase().replace(/\s+/g, '-').replace(/&/g, 'and');
        const isFirstOfCategory = !processedCategories.has(categorySlug);
        if (isFirstOfCategory) {
          processedCategories.add(categorySlug);
        }
        return (
        <div 
          class="masonry-item" 
          data-project={project.slug} 
          data-index={index} 
          data-lazy={index >= 6 ? "true" : "false"}
          id={isFirstOfCategory ? `category-${categorySlug}` : undefined}
         >
          <a href={`/projects/${project.slug}`} class="project-link" aria-label={`View ${project.data.title} project`}>
            <div class="image-container" data-loaded="false">
              <!-- Progressive loading placeholder -->
              <Picture 
                src={project.data.mainImage.src}
                alt={project.data.mainImage.alt}
                class="masonry-image"
                widths={[320, 640, 768, 1024]}
                sizes="(max-width: 550px) 100vw, (max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
                formats={['avif', 'webp']}
                fallbackFormat="webp"
                quality={index < 3 ? 75 : 60}
                loading={index < 3 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index < 3 ? "high" : "low"}
              />
              <div class="overlay">
                <div class="overlay-content">
                  <h3 class="project-title">{project.data.title}</h3>
                  <p class="project-category">{project.data.category}</p>
                </div>
              </div>
            </div>
          </a>
        </div>
      )}
    )}
  </Masonry>
</div>

<style>
  .masonry-container {
    min-height: 50dvh;
    width: 100%;
    margin: 0 auto;
    padding: 0 var(--spacing-container-mobile);
  }

  :global(.astro-masonry-grid) {
    display: flex;
    margin-left: calc(-1 * var(--spacing-grid-gap-mobile)); /* gutter size offset */
    width: auto;
  }

  :global(.astro-masonry-grid_column) {
    padding-left: var(--spacing-grid-gap-mobile); /* gutter size */
    background-clip: padding-box;
  }

  @media (min-width: 768px) {
    .masonry-container {
      padding: 0 var(--spacing-container-tablet);
    }
    :global(.astro-masonry-grid) {
      margin-left: -66px;
    }
    :global(.astro-masonry-grid_column) {
      padding-left: 66px;
    }
  }

  @media (min-width: 1512px) { /* Target client's screen size for specific margin */
    .masonry-container {
      padding: 0 121px;
    }
  }

  /* Global styles optimized for Motion.js animations */
  :global(.masonry-item) {
    width: 100%;
    margin-bottom: var(--spacing-grid-gap-mobile);
    
    /* Initial hidden state for Motion.js - will be handled by JavaScript */
    opacity: 0;
    transform: translate3d(0, 40px, 0) scale(0.95);
    
    /* Performance optimizations */
    will-change: opacity, transform;
    content-visibility: auto;
    contain: layout style;
    
    /* Smooth transitions for hover effects only */
    transition: box-shadow var(--transition-normal);
  }

  /* No animation for reduced motion users */
  :global(.masonry-item.no-animation) {
    opacity: 1 !important;
    transform: none !important;
    transition: none !important;
  }

  /* Responsive margin adjustments */
  @media (min-width: 768px) {
    :global(.masonry-item) {
      margin-bottom: 66px;
    }
  }

  .project-link {
    display: block;
    text-decoration: none;
    color: inherit;
    width: 100%;
    height: 100%;
  }

  .image-container {
    position: relative;
    overflow: hidden;
    border-radius: 0;
    cursor: pointer;
    background-color: var(--color-surface);
    width: 100%;
    display: block;
  }

  /* Progressive loading placeholder - using simple approach */
  :global(.image-placeholder) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--color-surface);
    z-index: 2;
    transition: opacity 0.4s ease;
  }

  /* Hide placeholder when image loads */
  :global(.image-container[data-loaded="true"]) :global(.image-placeholder) {
    opacity: 0;
  }

  :global(.image-placeholder.fade-out) {
    opacity: 0;
  }

  .masonry-image {
    width: 100%;
    height: auto;
    display: block;
    transition: transform var(--transition-normal);
    
    /* Performance and loading optimizations */
    content-visibility: auto;
    background-color: var(--color-surface);
    
    /* Hardware acceleration */
    transform: translateZ(0);
    will-change: transform;
  }


  /* Hover effects - only on non-touch devices */
  @media (hover: hover) and (pointer: fine) {
    :global(.masonry-item):hover {
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    }

    :global(.masonry-item):hover .overlay {
      opacity: 1;
      visibility: visible;
    }
  }

  /* Touch devices - show overlay on tap */
  @media (hover: none) and (pointer: coarse) {
    /* Handled by JS adding 'mobile-overlay-active' class */
    :global(.masonry-item.mobile-overlay-active) .overlay {
      opacity: 1;
      visibility: visible;
    }

    :global(.masonry-item):active .overlay {
      opacity: 0; /* Prevent flash on tap before JS logic runs */
    }
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--color-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: 
      opacity var(--transition-normal),
      visibility var(--transition-normal);
  }

  .overlay-content {
    text-align: center;
    padding: var(--spacing-md);
    color: white;
  }

  .project-title {
    font-family: var(--font-alt-heading);
    font-size: var(--text-lg);
    font-weight: 400;
    line-height: var(--leading-tight);
    margin-bottom: var(--spacing-xs);
    letter-spacing: var(--tracking-wide);
  }

  .project-category {
    font-family: var(--font-alt-heading);
    font-size: var(--text-sm);
    font-weight: 300;
    letter-spacing: var(--tracking-wider);
    opacity: 0.9;
    margin: 0;
  }

  /* Mobile spacing adjustments */
  @media (max-width: 549px) {
    .masonry-container {
      padding: 0 var(--spacing-container-mobile);
    }
  }

  /* Focus management for accessibility */
  :global(.masonry-item):focus-within {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  .project-link:focus {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  :global(.masonry-item) .project-link:focus .overlay {
    opacity: 1;
    visibility: visible;
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :global(.masonry-item) {
      animation: none !important;
      transition: none !important;
      will-change: auto;
      opacity: 1 !important;
      transform: none !important;
    }

    .masonry-grid {
      transition: none !important;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    :global(.masonry-item) {
      border: 2px solid ButtonText;
    }
    
    .overlay {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid ButtonText;
    }
  }

  /* Performance optimizations for large screens */
  @media (min-width: 1600px) {
    :global(.masonry-item) {
      contain-intrinsic-size: 382px 500px; /* Larger estimated size for desktop */
    }
  }
</style>

<!-- Motion.js + Lenis smooth scroll reveals -->

<script>
  console.log('ðŸš€ MasonryGrid script is executing...');
  
  // Image loading coordination with LoadingOverlay
  let eagerImagesLoaded = 0;
  let totalEagerImages = 0;
  let animationsReady = false;
  
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLoadingCoordination);
  } else {
    initializeLoadingCoordination();
  }
  
  function initializeLoadingCoordination() {
    console.log('ðŸŽ¯ Initializing loading coordination...');
    
    // Find the masonry container and eager images
    const container = document.querySelector('.masonry-container');
    if (!container) {
      console.warn('âŒ No masonry container found');
      return;
    }
    
    // Get all eager images (first 3-6 items based on loading="eager")
    const eagerImages = container.querySelectorAll('img[loading="eager"], img[fetchpriority="high"]');
    const allImages = container.querySelectorAll('img');
    
    // Fallback to first N images if no eager images found
    if (eagerImages.length === 0 && allImages.length > 0) {
      totalEagerImages = Math.min(3, allImages.length);
      console.log('âš¡ No eager images found, using first', totalEagerImages, 'images as critical');
      
      // Track first 3 images instead
      for (let i = 0; i < totalEagerImages; i++) {
        const img = allImages[i];
        if (img.complete && img.naturalWidth > 0) {
          console.log(`ðŸ”„ Image already cached: ${img.src.split('/').pop()}`);
          handleImageLoad(img);
        } else {
          img.addEventListener('load', () => handleImageLoad(img));
          img.addEventListener('error', () => {
            console.warn(`âŒ Image failed to load: ${img.src.split('/').pop()}`);
            handleImageLoad(img);
          });
        }
      }
    } else {
      totalEagerImages = eagerImages.length;
      console.log('ðŸ“¸ Found eager images to track:', totalEagerImages);
      
      if (totalEagerImages === 0) {
        console.log('âš¡ No images found, proceeding with animations immediately');
        startAnimations();
        return;
      }
    }
    
    // Track loading progress of eager images
    function updateLoadingProgress() {
      const progress = totalEagerImages > 0 ? (eagerImagesLoaded / totalEagerImages) * 100 : 100;
      console.log(`ðŸ“Š Loading progress: ${eagerImagesLoaded}/${totalEagerImages} (${Math.round(progress)}%)`);
      
      // Update the global loading overlay
      if (window.updateLoadingProgress) {
        window.updateLoadingProgress(progress);
      }
      
      // Start animations when all eager images are loaded
      if (eagerImagesLoaded >= totalEagerImages && !animationsReady) {
        console.log('ðŸŽ¬ All eager images loaded, preparing animations...');
        setTimeout(() => {
          setupTouchInteractions();
          startAnimations();
        }, 200); // Small delay to ensure overlay completes first
      }
    }
    
    // Handle image load events
    function handleImageLoad(img) {
      const container = img.closest('.image-container');
      if (container) {
        container.setAttribute('data-loaded', 'true');
      }
      
      eagerImagesLoaded++;
      console.log(`âœ… Eager image loaded: ${img.src.split('/').pop()}`);
      updateLoadingProgress();
    }
    
    // Check for already loaded images and add event listeners (only if we have eager images)
    if (eagerImages.length > 0) {
      eagerImages.forEach(img => {
        if (img.complete && img.naturalWidth > 0) {
          console.log(`ðŸ”„ Image already cached: ${img.src.split('/').pop()}`);
          handleImageLoad(img);
        } else {
          img.addEventListener('load', () => handleImageLoad(img));
          img.addEventListener('error', () => {
            console.warn(`âŒ Image failed to load: ${img.src.split('/').pop()}`);
            handleImageLoad(img); // Count failed images as "loaded" to avoid blocking
          });
        }
      });
    }
    
    // Add debugging for stuck loading
    setTimeout(() => {
      if (eagerImagesLoaded < totalEagerImages) {
        console.warn(`ðŸš¨ Loading stuck: ${eagerImagesLoaded}/${totalEagerImages} images loaded`);
        const remainingImages = eagerImages.length > 0 
          ? Array.from(eagerImages).filter(img => !img.complete).map(img => img.src)
          : Array.from(allImages).slice(0, totalEagerImages).filter(img => !img.complete).map(img => img.src);
        console.warn('Remaining images:', remainingImages);
      }
    }, 2000);
    
    // Fallback timeout - ensure animations start even if images fail
    setTimeout(() => {
      if (!animationsReady) {
        console.log('â° Fallback timeout reached, starting animations');
        if (window.updateLoadingProgress) {
          window.updateLoadingProgress(100);
        }
        setupTouchInteractions();
        startAnimations();
      }
    }, 3000);
    
    // Initialize immediately if images are already cached
    if (eagerImagesLoaded >= totalEagerImages) {
      updateLoadingProgress();
    }

    function setupTouchInteractions() {
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      if (!isTouchDevice) return;

      const masonryItems = document.querySelectorAll('.masonry-item');
      let tappedItem = null;

      masonryItems.forEach(item => {
        const link = item.querySelector('.project-link');

        link.addEventListener('click', (e) => {
          if (item !== tappedItem) {
            e.preventDefault();

            // Remove active class from previously tapped item
            if (tappedItem) {
              tappedItem.classList.remove('mobile-overlay-active');
            }
            
            // Add active class to current item and set it as tapped
            item.classList.add('mobile-overlay-active');
            tappedItem = item;
          }
          // If it's the second tap, the default link behavior will proceed
        });
      });

      // Add a listener to the document to close the overlay if tapping outside
      document.addEventListener('click', (e) => {
        if (tappedItem && !tappedItem.contains(e.target)) {
          tappedItem.classList.remove('mobile-overlay-active');
          tappedItem = null;
        }
      });
    }
  }
  
  async function startAnimations() {
    if (animationsReady) return; // Prevent double initialization
    animationsReady = true;
    
    console.log('ðŸŽ­ Starting Motion.js animations...');
    
    try {
      // Import Motion.js functions dynamically
      const { animate, inView } = await import('motion');
      console.log('âœ… Motion.js imported successfully');
      
      // Find the masonry container
      const container = document.querySelector('.masonry-container');
      const uniqueId = container?.id;
      
      if (!uniqueId || !animate || !inView) {
        console.warn('âŒ Missing container or Motion.js functions');
        applyFallbackVisibility();
        return;
      }
      
      const items = container.querySelectorAll('.masonry-item');
      console.log('ðŸŽ¬ Setting up animations for', items.length, 'masonry items');
      
      // Wait for loading complete event from overlay
      const startItemAnimations = () => {
        console.log('ðŸŒŸ Loading overlay complete, starting item reveals...');
        
        // Use inView for all items to ensure consistent scroll-triggered animation
        items.forEach((item, index) => {
          inView(
            item,
            () => {
              animate(
                item,
                {
                  opacity: [0, 1],
                  transform: ['translate3d(0, 40px, 0) scale(0.95)', 'translate3d(0, 0, 0) scale(1)']
                },
                {
                  duration: 0.8,
                  ease: [0.25, 0.46, 0.45, 0.94],
                  // Stagger the animation delay for a cascade effect
                  delay: (index % 9) * 0.1
                }
              );
            },
            { margin: '-20% 0px -10% 0px' }
          );
        });
        
        console.log('âœ¨ Masonry animations initialized successfully!');
      };
      
      // Listen for loading complete event from overlay
      document.addEventListener('loadingComplete', startItemAnimations);

      // Also ensure touch interactions are set up after animations start
      document.addEventListener('loadingComplete', () => {
        setupTouchInteractions();
      });
      
      // Fallback: start animations after a delay if event doesn't fire
      setTimeout(() => {
        if (document.querySelectorAll('.masonry-item[style*="opacity: 1"]').length === 0) {
          console.log('ðŸ”„ Fallback: starting animations without overlay event');
          startItemAnimations();
        }
      }, 4000);
      
    } catch (error) {
      console.error('ðŸ’¥ Failed to initialize masonry animations:', error);
      applyFallbackVisibility();
    }
  }
  
  function applyFallbackVisibility() {
    console.log('ðŸ”„ Applying fallback visibility...');
    const items = document.querySelectorAll('.masonry-item');
    items.forEach(item => {
      item.style.opacity = '1';
      item.style.transform = 'none';
    });
    console.log('âœ… Fallback applied to', items.length, 'items');
  }
</script>
