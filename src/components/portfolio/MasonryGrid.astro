---
// MasonryGrid.astro - Astro-native masonry grid with Motion.js animations
// Optimized for performance with fixed order and smooth animations

import { Picture } from 'astro:assets';
import { Masonry } from 'astro-masonry';
import type { CollectionEntry } from 'astro:content';

export interface Props {
  projects: CollectionEntry<'projects'>[];
  className?: string;
}

const { projects = [], className = '' } = Astro.props;

// Generate unique ID for this masonry instance
const uniqueId = `masonry-${Math.random().toString(36).substr(2, 9)}`;

// Sort projects for fixed, consistent order (by featured status, then date)
const sortedProjects = projects.sort((a, b) => {
  // Featured projects first
  if (a.data.featured && !b.data.featured) return -1;
  if (!a.data.featured && b.data.featured) return 1;
  
  // Then by date (newest first)
  const dateA = new Date(a.data.publishedDate || 0);
  const dateB = new Date(b.data.publishedDate || 0);
  return dateB.getTime() - dateA.getTime();
});
---

<div class={`masonry-container ${className}`} id={uniqueId}>
  <Masonry 
    breakpointCols={{
      default: 3,
      1600: 3,
      900: 2,
      550: 1
    }}
  >
    {sortedProjects.map((project, index) => 
        <div class="masonry-item" data-project={project.slug} data-index={index} data-lazy={index >= 6 ? "true" : "false"}>
          <a href={`/projects/${project.slug}`} class="project-link" aria-label={`View ${project.data.title} project`}>
            <div class="image-container" data-loaded="false">
              <!-- Progressive loading placeholder -->
              <Picture 
                src={project.data.mainImage.src}
                alt={project.data.mainImage.alt}
                class="masonry-image"
                widths={[320, 640, 768, 1024]}
                sizes="(max-width: 550px) 100vw, (max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
                formats={['avif', 'webp']}
                fallbackFormat="webp"
                quality={index < 3 ? 75 : 60}
                loading={index < 3 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index < 3 ? "high" : "low"}
              />
              <div class="overlay">
                <div class="overlay-content">
                  <h3 class="project-title">{project.data.title}</h3>
                  <p class="project-category">{project.data.category}</p>
                </div>
              </div>
            </div>
          </a>
        </div>
      )
    }
        {sortedProjects.map((project, index) => 
        <div class="masonry-item" data-project={project.slug} data-index={index} data-lazy={index >= 6 ? "true" : "false"}>
          <a href={`/projects/${project.slug}`} class="project-link" aria-label={`View ${project.data.title} project`}>
            <div class="image-container" data-loaded="false">
              <!-- Progressive loading placeholder -->
              <Picture 
                src={project.data.mainImage.src}
                alt={project.data.mainImage.alt}
                class="masonry-image"
                widths={[320, 640, 768, 1024]}
                sizes="(max-width: 550px) 100vw, (max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
                formats={['avif', 'webp']}
                fallbackFormat="webp"
                quality={index < 3 ? 75 : 60}
                loading={index < 3 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index < 3 ? "high" : "low"}
              />
              <div class="overlay">
                <div class="overlay-content">
                  <h3 class="project-title">{project.data.title}</h3>
                  <p class="project-category">{project.data.category}</p>
                </div>
              </div>
            </div>
          </a>
        </div>
      )
    }    {sortedProjects.map((project, index) => 
        <div class="masonry-item" data-project={project.slug} data-index={index} data-lazy={index >= 6 ? "true" : "false"}>
          <a href={`/projects/${project.slug}`} class="project-link" aria-label={`View ${project.data.title} project`}>
            <div class="image-container" data-loaded="false">
              <!-- Progressive loading placeholder -->
              <Picture 
                src={project.data.mainImage.src}
                alt={project.data.mainImage.alt}
                class="masonry-image"
                widths={[320, 640, 768, 1024]}
                sizes="(max-width: 550px) 100vw, (max-width: 768px) 50vw, (max-width: 1200px) 33vw, 25vw"
                formats={['avif', 'webp']}
                fallbackFormat="webp"
                quality={index < 3 ? 75 : 60}
                loading={index < 3 ? "eager" : "lazy"}
                decoding="async"
                fetchpriority={index < 3 ? "high" : "low"}
              />
              <div class="overlay">
                <div class="overlay-content">
                  <h3 class="project-title">{project.data.title}</h3>
                  <p class="project-category">{project.data.category}</p>
                </div>
              </div>
            </div>
          </a>
        </div>
      )
    }
  </Masonry>
</div>

<!-- Native CSS animations with Cell Art style scroll reveals -->

<script define:vars={{ uniqueId }}>
  document.addEventListener('DOMContentLoaded', () => {
    // Find the masonry grid for this specific component instance
    const containerElement = document.getElementById(uniqueId);
    if (!containerElement) return;
    
    const masonryContainer = containerElement.querySelector('.masonry-grid');
    if (!masonryContainer) return;

    // Enhanced image loading with blur-to-sharp effect
    let eagerImagesLoaded = 0;
    const totalImages = masonryContainer.querySelectorAll('.masonry-image').length;
    const eagerImages = Math.min(3, totalImages);
    let animationsInitialized = false;
    
    console.log(`MasonryGrid: Found ${totalImages} images, ${eagerImages} eager images expected`);
    
    // Robust progress update with retry mechanism
    function updateLoadingProgressSafely(progress, retries = 0) {
      const maxRetries = 10;
      const retryDelay = 50; // 50ms between retries
      
      if (window.updateLoadingProgress) {
        console.log(`MasonryGrid: Successfully calling updateLoadingProgress(${progress})`);
        window.updateLoadingProgress(progress);
      } else if (retries < maxRetries) {
        console.log(`MasonryGrid: Function not ready, retrying in ${retryDelay}ms (attempt ${retries + 1}/${maxRetries})`);
        setTimeout(() => {
          updateLoadingProgressSafely(progress, retries + 1);
        }, retryDelay);
      } else {
        console.warn(`MasonryGrid: Failed to call updateLoadingProgress after ${maxRetries} retries`);
      }
    }

    // Intersection Observer for scroll-based animations
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '50px 0px -50px 0px'
    };

    const revealObserver = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          const item = entry.target;
          const itemIndex = parseInt(item.dataset.index || '0');
          
          // Add stagger delay based on item index
          item.style.setProperty('--reveal-delay', `${itemIndex * 0.1}s`);
          item.classList.add('reveal');
          
          revealObserver.unobserve(item);
        }
      });
    }, observerOptions);

    function handleImageLoad(img, isEager = false) {
      const container = img.closest('.image-container');
      const placeholder = container?.querySelector('.image-placeholder');
      const masonryItem = container?.closest('.masonry-item');
      
      if (container) {
        container.setAttribute('data-loaded', 'true');
      }
      
      // Hide placeholder with blur-to-sharp effect
      if (placeholder) {
        placeholder.classList.add('fade-out');
      }
      
      if (isEager) {
        eagerImagesLoaded++;
        console.log(`MasonryGrid: Eager image ${eagerImagesLoaded}/${eagerImages} loaded`);
        
        // Update loading progress - more generous progress calculation
        const progress = Math.min(100, (eagerImagesLoaded / eagerImages) * 100);
        console.log(`MasonryGrid: Updating progress to ${progress}%`);
        updateLoadingProgressSafely(progress);
      }

      // Initialize animations after eager images load
      if (eagerImagesLoaded >= eagerImages && !animationsInitialized) {
        animationsInitialized = true;
        
        // Ensure we hit 100%
        console.log(`MasonryGrid: Ensuring 100% completion`);
        updateLoadingProgressSafely(100);
        
        setTimeout(() => {
          // Reveal eager items immediately
          const eagerItems = masonryContainer.querySelectorAll('.masonry-item:not([data-lazy="true"])');
          eagerItems.forEach((item, index) => {
            item.style.setProperty('--reveal-delay', `${index * 0.15}s`);
            item.classList.add('reveal');
          });

          // Observe lazy items for scroll-based reveal
          const lazyItems = masonryContainer.querySelectorAll('.masonry-item[data-lazy="true"]');
          lazyItems.forEach(item => {
            revealObserver.observe(item);
          });
        }, 100);
      }

      // For lazy images, observe for scroll reveal
      if (masonryItem && !isEager && !masonryItem.classList.contains('reveal')) {
        revealObserver.observe(masonryItem);
      }
    }

    // Check for already loaded images (cached images)
    const images = masonryContainer.querySelectorAll('.masonry-image');
    let cachedEagerCount = 0;
    
    images.forEach((img, index) => {
      const isEager = img.loading === 'eager';
      if (img.complete && img.naturalWidth > 0) {
        console.log(`MasonryGrid: Image ${index} already loaded (cached)`);
        if (isEager) {
          cachedEagerCount++;
        }
        // Process cached image immediately - no timeout needed
        handleImageLoad(img, isEager);
      }
    });
    
    console.log(`MasonryGrid: Found ${cachedEagerCount}/${eagerImages} cached eager images`);

    // Listen for image load events
    masonryContainer.addEventListener('load', (event) => {
      const target = event.target;
      if (target?.tagName === 'IMG' && target.classList.contains('masonry-image')) {
        const isEager = target.loading === 'eager';
        console.log(`MasonryGrid: Image load event fired`, target.src);
        handleImageLoad(target, isEager);
      }
    }, true);

    // Focus management for accessibility
    masonryContainer.addEventListener('focusin', (event) => {
      const focusedItem = event.target.closest('.masonry-item');
      if (focusedItem) {
        const img = focusedItem.querySelector('.masonry-image');
        if (img && img.loading === 'lazy') {
          img.setAttribute('fetchpriority', 'high');
        }
      }
    });

    // Handle reduced motion preferences
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    if (prefersReducedMotion) {
      const items = masonryContainer.querySelectorAll('.masonry-item');
      items.forEach(item => {
        item.classList.add('no-animation');
      });
    }
    
    // Listen for loading complete event from overlay
    document.addEventListener('loadingComplete', () => {
      // Ensure content is visible and animations can start
      if (!animationsInitialized) {
        // Trigger reveal for all eager items if not already done
        const eagerItems = masonryContainer.querySelectorAll('.masonry-item:not([data-lazy="true"])');
        eagerItems.forEach((item, index) => {
          item.style.setProperty('--reveal-delay', `${index * 0.15}s`);
          item.classList.add('reveal');
        });
      }
    });
  });
</script>

<style>
  .masonry-container {
    min-height: 50dvh;
    width: 100%;
    margin: 0 auto;
    padding: 0 var(--spacing-container-mobile);
  }

  @media (min-width: 768px) {
    .masonry-container {
      padding: 0 var(--spacing-container-tablet);
    }
  }

  @media (min-width: 1200px) {
    .masonry-container {
      padding: 0 var(--spacing-container-desktop);
    }
  }

    :global(.astro-masonry-grid_column) {
      padding-left: calc(var(--spacing-grid-gap-mobile));
      padding-right: calc(var(--spacing-grid-gap-mobile));
    }

  /* Responsive gap adjustments */
  @media (min-width: 768px) {
    :global(.astro-masonry-grid_column) {
      padding-left: calc(var(--spacing-grid-gap-tablet) / 2);
      padding-right: calc(var(--spacing-grid-gap-tablet) / 2);
    }
  }

  @media (min-width: 1200px) {
    :global(.astro-masonry-grid_column) {
      padding-left: calc(var(--spacing-grid-gap-desktop) / 3);
      padding-right: calc(var(--spacing-grid-gap-desktop) / 3);
    }
  }

  /* Global styles for JavaScript interaction */
  :global(.masonry-item) {
    width: 100%;
    margin-bottom: var(--spacing-grid-gap-mobile);
    
    /* Initial hidden state with Cell Art style */
/*     opacity: 0;
    clip-path: inset(100% 0% 0% 0%);
    transform: translateY(20px) scale(0.95) translateZ(0); */
    
    /* Performance optimizations */
    will-change: opacity, clip-path, transform;
    content-visibility: auto;
    contain: layout style;
    
    /* Transition properties */
    transition: 
      opacity 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      clip-path 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      transform 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94),
      box-shadow var(--transition-normal);
  }

  /* Cell Art style reveal animation */
  :global(.masonry-item.reveal) {
    opacity: 1;
    clip-path: inset(0% 0% 0% 0%);
    transform: translateY(0) scale(1) translateZ(0);
    transition-delay: var(--reveal-delay, 0s);
  }

  /* No animation for reduced motion users */
  :global(.masonry-item.no-animation) {
    opacity: 1 !important;
    clip-path: inset(0% 0% 0% 0%) !important;
    transform: translateY(0) scale(1) translateZ(0) !important;
    transition: none !important;
  }

  /* Responsive margin adjustments */
  @media (min-width: 768px) {
    :global(.masonry-item) {
      margin-bottom: var(--spacing-grid-gap-tablet);
    }
  }

  @media (min-width: 1200px) {
    :global(.masonry-item) {
      margin-bottom: var(--spacing-grid-gap-desktop);
    }
  }

  .project-link {
    display: block;
    text-decoration: none;
    color: inherit;
    width: 100%;
    height: 100%;
  }

  .image-container {
    position: relative;
    overflow: hidden;
    border-radius: 0;
    cursor: pointer;
    background-color: var(--color-surface);
    width: 100%;
    display: block;
  }

  /* Progressive loading placeholder - using simple approach */
  :global(.image-placeholder) {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--color-surface);
    z-index: 2;
    transition: opacity 0.4s ease;
  }

  /* Hide placeholder when image loads */
  :global(.image-container[data-loaded="true"]) :global(.image-placeholder) {
    opacity: 0;
  }

  :global(.image-placeholder.fade-out) {
    opacity: 0;
  }

  .masonry-image {
    width: 100%;
    height: auto;
    display: block;
    transition: transform var(--transition-normal);
    
    /* Performance and loading optimizations */
    content-visibility: auto;
    background-color: var(--color-surface);
    
    /* Hardware acceleration */
    transform: translateZ(0);
    will-change: transform;
  }


  /* Hover effects - only on non-touch devices */
  @media (hover: hover) and (pointer: fine) {
    :global(.masonry-item.reveal):hover {
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
    }

    :global(.masonry-item.reveal):hover .overlay {
      opacity: 1;
      visibility: visible;
    }
  }

  /* Touch devices - show overlay on tap */
  @media (hover: none) and (pointer: coarse) {
    :global(.masonry-item):active .overlay {
      opacity: 1;
      visibility: visible;
    }
  }

  .overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: var(--color-overlay);
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    visibility: hidden;
    transition: 
      opacity var(--transition-normal),
      visibility var(--transition-normal);
  }

  .overlay-content {
    text-align: center;
    padding: var(--spacing-md);
    color: white;
  }

  .project-title {
    font-family: var(--font-alt-heading);
    font-size: var(--text-lg);
    font-weight: 400;
    line-height: var(--leading-tight);
    margin-bottom: var(--spacing-xs);
    letter-spacing: var(--tracking-wide);
  }

  .project-category {
    font-family: var(--font-alt-heading);
    font-size: var(--text-sm);
    font-weight: 300;
    letter-spacing: var(--tracking-wider);
    opacity: 0.9;
    margin: 0;
  }

  /* Mobile spacing adjustments */
  @media (max-width: 549px) {
    .masonry-container {
      padding: 0 var(--spacing-container-mobile);
    }
  }

  /* Focus management for accessibility */
  :global(.masonry-item.reveal):focus-within {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  .project-link:focus {
    outline: 2px solid var(--color-primary);
    outline-offset: 4px;
  }

  :global(.masonry-item.reveal) .project-link:focus .overlay {
    opacity: 1;
    visibility: visible;
  }

  /* Accessibility: Respect reduced motion preferences */
  @media (prefers-reduced-motion: reduce) {
    :global(.masonry-item) {
      animation: none !important;
      transition: none !important;
      will-change: auto;
      opacity: 1 !important;
      clip-path: inset(0% 0% 0% 0%) !important;
      transform: translateY(0) scale(1) translateZ(0) !important;
    }

    .masonry-grid {
      transition: none !important;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    :global(.masonry-item) {
      border: 2px solid ButtonText;
    }
    
    .overlay {
      background: rgba(0, 0, 0, 0.9);
      border: 1px solid ButtonText;
    }
  }

  /* Performance optimizations for large screens */
  @media (min-width: 1600px) {
    :global(.masonry-item) {
      contain-intrinsic-size: 382px 500px; /* Larger estimated size for desktop */
    }
  }
</style>