---
export interface Props {
  text: string;
  className?: string;
  tag?: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
  animationDelay?: number;
}

const { 
  text, 
  className = "", 
  tag = "h1",
  animationDelay = 0 
} = Astro.props;

const Tag = tag;
---

<div class={`header-animation ${className}`} data-text={text}>
  <Tag class="animated-header" data-splittext data-animation-delay={animationDelay}>
    {text}
  </Tag>
</div>

<script>
  import { animate } from "motion";


  class HeaderAnimation {
    constructor(element) {
      this.element = element;
      this.headerEl = element.querySelector('[data-splittext]');
      this.syllables = [];
      this.syllablePositions = [];
      this.hasAnimated = false;
      this.observer = null;
      
      if (this.headerEl) {
        this.init();
      }
    }

    async init() {
      if (!this.headerEl) return;
      
      await this.splitTextIntoSyllables();
      this.setupIntersectionObserver();
    }

    async splitTextIntoSyllables() {
      if (!this.headerEl) return;
      
      const text = this.headerEl.textContent || '';
      this.headerEl.innerHTML = '';
      
      // Define syllable groups for "LUCINDA BURMAN"
      const syllableGroups = ['LUC', 'I', 'N', 'DA', '\u00A0', 'B', 'URM', 'A', 'N'];
      
      // Create span elements for each syllable group
      syllableGroups.forEach((syllable, index) => {
        const span = document.createElement('span');
        span.textContent = syllable;
        span.className = 'syllable';
        span.setAttribute('data-syllable-index', index.toString());
        span.style.display = 'inline-block';
        span.style.whiteSpace = 'nowrap'; // Keep syllables together
        this.syllables.push(span);
        this.headerEl.appendChild(span);
      });

      // Set initial state - syllables positioned with criss-cross pattern
      this.setSyllableInitialPositions();
    }

    setSyllableInitialPositions() {
      // Get container width for strategic positioning
      const containerRect = this.headerEl.getBoundingClientRect();
      const containerWidth = containerRect.width || 500; // fallback width
      
      // Define criss-cross starting positions for each syllable and store for animation
      this.syllablePositions = [
        { x: containerWidth * 0.7, y: -40, name: 'LUC' },    // top-right
        { x: -containerWidth * 0.1, y: -35, name: 'I' },     // top-left (negative X for left side)
        { x: -containerWidth * 0.15, y: -45, name: 'N' },    // top-left (offset)
        { x: containerWidth * 0.5, y: -40, name: 'DA' },     // top-middle
        { x: 0, y: 0, name: 'SPACE' },                       // space (no movement)
        { x: containerWidth * 0.8, y: -35, name: 'B' },      // top-right
        { x: -containerWidth * 0.2, y: -40, name: 'URM' },   // top-left (negative X)
        { x: containerWidth * 0.75, y: -45, name: 'A' },     // top-right (offset)
        { x: -containerWidth * 0.25, y: -35, name: 'N' }     // top-left (negative X)
      ];

      this.syllables.forEach((syllable, index) => {
        const position = this.syllablePositions[index];
        if (position.name === 'SPACE') {
          // Handle space differently - make it visible immediately
          syllable.style.opacity = '1';
          syllable.style.transform = 'translateX(0px) translateY(0px) scale(1)';
        } else {
          syllable.style.opacity = '0';
          syllable.style.transform = `translateX(${position.x}px) translateY(${position.y}px) scale(0.9)`;
        }
      });
    }

    setupIntersectionObserver() {
      // Listen for loading completion event
      document.addEventListener('loadingComplete', this.startAnimation.bind(this));
      
      // Fallback: If no loading overlay is present, use intersection observer as before
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.hasAnimated) {
            // Only trigger if loading overlay hasn't completed yet
            const overlay = document.getElementById('loading-overlay');
            const isOverlayActive = overlay && overlay.style.display !== 'none';
            
            if (!isOverlayActive) {
              this.startAnimation();
            }
          }
        });
      }, { 
        threshold: 0.3,
        rootMargin: '0px 0px -10% 0px'
      });
      
      this.observer.observe(this.element);
    }

    async playEntranceAnimation(reducedMotion = false) {
      if (this.syllables.length === 0) return;
      
      // Fallback: ensure text is visible even if animation fails
      const ensureVisibility = () => {
        this.syllables.forEach(syllable => {
          syllable.style.opacity = '1';
          syllable.style.transform = 'translateX(0px) translateY(0px) scale(1)';
        });
      };

      // Set a fallback timeout
      const fallbackTimeout = setTimeout(ensureVisibility, 2000);
      
      try {
        if (reducedMotion) {
          // Simple fade-in for users who prefer reduced motion
          const animationConfig = {
            opacity: [0, 1],
            y: [0, 0],
            scale: [1, 1]
          };

          const options = {
            delay: 0,
            duration: 0.3,
            ease: "linear"
          };

          this.syllables.forEach((syllable, index) => {
            // Skip the space element (index 4)
            if (index === 4) return;
            
            animate(syllable, animationConfig, {
              ...options,
              delay: index * 0.1 // Slightly longer delay for syllables
            });
          });
          clearTimeout(fallbackTimeout);
        } else {
          // Syllable-based criss-cross flow animation
          const baseOptions = {
            delay: 0,
            duration: 1.2,
            ease: "easeOut"
          };

          this.syllables.forEach((syllable, index) => {
            // Skip the space element (index 4)
            if (index === 4) return;
            
            // Rhythmic flow timing with shorter delays for continuous flow
            const staggerDelay = index * 0.12; // 120ms between syllable starts for flowy cadence
            
            // Get the actual starting position for this syllable
            const startingPosition = this.syllablePositions[index];
            
            // Each syllable moves from its strategic position to final position (0, 0)
            const animationConfig = {
              opacity: [0, 1],
              x: [startingPosition.x, 0], // From scattered X position to center
              y: [startingPosition.y, 0], // From above Y position to baseline
              scale: [0.9, 1]
            };
            
            animate(syllable, animationConfig, {
              ...baseOptions,
              delay: staggerDelay
            }).finished.then(() => {
              // Clear fallback timeout when final syllable completes
              if (index === this.syllables.length - 1) clearTimeout(fallbackTimeout);
            }).catch(() => {
              // On animation error, ensure visibility
              ensureVisibility();
              clearTimeout(fallbackTimeout);
            });
          });
        }
      } catch (error) {
        console.warn('Header animation failed, falling back to static text:', error);
        ensureVisibility();
        clearTimeout(fallbackTimeout);
      }
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }
      // Clean up loading complete event listener
      document.removeEventListener('loadingComplete', this.startAnimation.bind(this));
    }
    
    startAnimation() {
      if (!this.hasAnimated) {
        const animationDelay = parseInt((this.headerEl && this.headerEl.getAttribute('data-animation-delay')) || '0');
        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        setTimeout(() => {
          this.playEntranceAnimation(prefersReducedMotion);
        }, animationDelay);
        this.hasAnimated = true;
      }
    }
  }

  // Initialize animations when DOM is ready
  const initializeAnimations = () => {
    const animationElements = document.querySelectorAll('.header-animation');
    
    animationElements.forEach(element => {
      if (element instanceof HTMLElement) {
        new HeaderAnimation(element);
      }
    });
  };

  // Initialize immediately if DOM is already loaded, otherwise wait
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeAnimations);
  } else {
    initializeAnimations();
  }

  // Re-initialize on navigation in Astro
  document.addEventListener('astro:page-load', initializeAnimations);
</script>

<style>
  .header-animation {
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
  }

  .animated-header {
    color: var(--color-text-primary, #000000);
    letter-spacing: var(--tracking-wider);
    margin: 0;
    line-height: var(--leading-tight);
    text-align: center;
    overflow: visible;
  }

  .animated-header .syllable {
    transition: transform 0.1s ease-out;
    will-change: transform, opacity;
  }

  /* Responsive adjustments */
  @media (max-width: 768px) {
    .animated-header {
      letter-spacing: var(--tracking-normal, 0);
    }
    
    .header-animation {
      padding: var(--space-sm, 1rem);
      min-height: 4rem;
    }
  }

  @media (max-width: 480px) {
    .animated-header {
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .animated-header {
      color: var(--color-text-primary, #000000);
      font-weight: 500;
    }
  }

  /* Print styles */
  @media print {
    .header-animation {
      min-height: auto;
    }
    
    .animated-header .syllable {
      opacity: 1 !important;
      transform: none !important;
    }
  }
</style>