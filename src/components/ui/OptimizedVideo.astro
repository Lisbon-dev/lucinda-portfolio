---
interface Props {
  src: string;
  poster?: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
}

const { src, poster, alt, width, height, class: className } = Astro.props;

// Generate different video formats for the same source
const videoBase = src.replace(/\.[^/.]+$/, ""); // Remove extension
const formats = [
  { src: `${videoBase}.webm`, type: 'video/webm' },
  { src: `${videoBase}.mp4`, type: 'video/mp4' }
];
---

<div class={`video-container ${className || ''}`}>
  <video
    class="optimized-video"
    width={width}
    height={height}
    poster={poster}
    muted
    loop
    playsinline
    preload="metadata"
    aria-label={alt}
    data-video-src={src}
  >
    {formats.map(format => (
      <source src={format.src} type={format.type} />
    ))}
    <!-- Fallback for browsers that don't support video -->
    <p class="video-fallback">
      Your browser doesn't support video playback. 
      <a href={src} download>Download the video</a> to view it.
    </p>
  </video>
  
  <!-- Screen reader description -->
  <span class="sr-only">{alt}</span>
</div>

<script>
  class OptimizedVideo {
    constructor() {
      this.setupIntersectionObserver();
      this.setupNetworkAwareLoading();
      this.setupReducedMotionSupport();
      this.setupClickToToggle();
    }

    setupIntersectionObserver() {
      const videos = document.querySelectorAll('.optimized-video[data-video-src]');
      
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const video = entry.target as HTMLVideoElement;
          
          if (entry.isIntersecting) {
            this.playVideo(video);
          } else {
            video.pause();
          }
        });
      }, {
        rootMargin: '50px 0px',
        threshold: 0.1
      });

      videos.forEach(video => observer.observe(video));
    }

    setupNetworkAwareLoading() {
      // Check for slow connections
      const connection = (navigator as any).connection;
      if (connection) {
        const isSlowConnection = connection.effectiveType === 'slow-2g' || 
                                connection.effectiveType === '2g' ||
                                connection.saveData;
        
        if (isSlowConnection) {
          // Disable autoplay on slow connections
          document.querySelectorAll('.optimized-video').forEach(video => {
            (video as HTMLVideoElement).autoplay = false;
            (video as HTMLVideoElement).preload = 'none';
          });
        }
      }
    }

    setupReducedMotionSupport() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      
      const handleMotionPreference = (e: MediaQueryListEvent | MediaQueryList) => {
        const videos = document.querySelectorAll('.optimized-video');
        videos.forEach(video => {
          const videoElement = video as HTMLVideoElement;
          if (e.matches) {
            // User prefers reduced motion
            videoElement.autoplay = false;
            videoElement.pause();
          }
        });
      };

      prefersReducedMotion.addEventListener('change', handleMotionPreference);
      handleMotionPreference(prefersReducedMotion);
    }

    setupClickToToggle() {
      document.querySelectorAll('.optimized-video').forEach(videoEl => {
        videoEl.addEventListener('click', () => {
          const video = videoEl as HTMLVideoElement;
          if (video.paused) {
            video.play().catch(e => console.warn("Play interrupted by user", e));
          } else {
            video.pause();
          }
        });
      });
    }

    playVideo(video: HTMLVideoElement) {
      const src = video.dataset.videoSrc;
      // Check if source needs to be set (for lazy loading)
      if (src && video.currentSrc === '') {
        video.load(); // This will trigger loading sources
        
        // Handle loading states
        video.addEventListener('loadstart', () => {
          video.classList.add('loading');
        });

        video.addEventListener('error', () => {
          video.classList.add('error');
          console.warn('Video failed to load:', src);
        });
      }
      
      const playPromise = video.play();
      if (playPromise !== undefined) {
        playPromise.then(() => {
          video.classList.remove('loading');
          video.classList.add('loaded');
        }).catch(error => {
          console.warn("Video autoplay was prevented:", error);
        });
      }
    }
  }

  // Initialize when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => new OptimizedVideo());
  } else {
    new OptimizedVideo();
  }
</script>

<style>
  .video-container {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .optimized-video {
    width: 100%;
    height: auto;
    display: block;
    background-color: var(--color-background-secondary, #f5f5f5);
    transition: opacity var(--transition-normal, 0.3s ease);
  }

  .optimized-video.loading {
    opacity: 0.7;
  }

  .optimized-video.loaded {
    opacity: 1;
  }

  .optimized-video.error {
    opacity: 0.5;
    filter: grayscale(1);
  }

  .video-fallback {
    padding: var(--spacing-md, 1rem);
    text-align: center;
    background-color: var(--color-background-secondary, #f5f5f5);
    border-radius: var(--rounded-sm, 4px);
    color: var(--color-text-secondary, #666);
  }

  .video-fallback a {
    color: var(--color-primary, #007acc);
    text-decoration: underline;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Respect user's motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .optimized-video {
      animation: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .video-container {
      border: 2px solid ButtonText;
    }
  }
</style>
