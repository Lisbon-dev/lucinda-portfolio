---
interface Props {
  src: string;
  poster?: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
}

const { src, poster, alt, width, height, class: className } = Astro.props;

// Generate different video formats for the same source
const videoBase = src.replace(/\.[^/.]+$/, ""); // Remove extension
const formats = [
  { src: `${videoBase}.webm`, type: 'video/webm' },
  { src: `${videoBase}.mp4`, type: 'video/mp4' }
];
---

<div class={`video-container ${className || ''}`}>
  <video
    class="optimized-video"
    width={width}
    height={height}
    poster={poster}
    muted
    autoplay
    loop
    playsinline
    preload="metadata"
    aria-label={alt}
    data-video-src={src}
    data-click-to-pause="true"
  >
    {formats.map(format => (
      <source src={format.src} type={format.type} />
    ))}
    <!-- Fallback for browsers that don't support video -->
    <p class="video-fallback">
      Your browser doesn't support video playback. 
      <a href={src} download>Download the video</a> to view it.
    </p>
  </video>
  
  <!-- Screen reader description -->
  <span class="sr-only">{alt}</span>
</div>

<script>
  class OptimizedVideo {
    private observer: IntersectionObserver | null = null;
    private playAttempts: Map<HTMLVideoElement, number> = new Map();
    private readonly MAX_PLAY_ATTEMPTS = 2; // Reduced from 3
    private eventCleanupFunctions: Map<HTMLVideoElement, (() => void)[]> = new Map();

    constructor() {
      this.setupIntersectionObserver();
      this.setupNetworkAwareLoading();
      this.setupReducedMotionSupport();
      this.initializeVideos();
    }

    initializeVideos() {
      const videos = document.querySelectorAll('.optimized-video[data-video-src]');
      
      videos.forEach(videoEl => {
        const video = videoEl as HTMLVideoElement;
        
        // Initialize cleanup array for this video
        this.eventCleanupFunctions.set(video, []);
        
        // CRITICAL: Set iOS-required attributes via both property AND attribute
        video.muted = true;
        video.playsInline = true;
        video.setAttribute('muted', '');
        video.setAttribute('playsinline', '');
        
        // Set up event listeners with proper cleanup tracking
        this.setupVideoEventListeners(video);
        
        // Attempt immediate play for above-the-fold videos (with error handling)
        setTimeout(() => {
          try {
            this.playVideo(video);
          } catch (error) {
            console.warn('Initial video play failed:', error);
          }
        }, 100);
      });
    }

    setupVideoEventListeners(video: HTMLVideoElement) {
      const cleanupFunctions = this.eventCleanupFunctions.get(video) || [];

      // Loadstart handler
      const handleLoadStart = () => video.classList.add('loading');
      video.addEventListener('loadstart', handleLoadStart);
      cleanupFunctions.push(() => video.removeEventListener('loadstart', handleLoadStart));

      // Loadeddata handler
      const handleLoadedData = () => {
        video.classList.remove('loading');
        video.classList.add('loaded');
      };
      video.addEventListener('loadeddata', handleLoadedData);
      cleanupFunctions.push(() => video.removeEventListener('loadeddata', handleLoadedData));

      // Error handler
      const handleError = () => {
        video.classList.add('error');
        console.warn('Video failed to load:', video.dataset.videoSrc);
        // Stop retry attempts on error
        this.playAttempts.set(video, this.MAX_PLAY_ATTEMPTS);
      };
      video.addEventListener('error', handleError);
      cleanupFunctions.push(() => video.removeEventListener('error', handleError));

      // Playing handler
      const handlePlaying = () => {
        video.classList.remove('loading');
        video.classList.add('loaded');
      };
      video.addEventListener('playing', handlePlaying);
      cleanupFunctions.push(() => video.removeEventListener('playing', handlePlaying));

      // Simplified pause handler - no automatic retry
      const handlePause = () => {
        // Only log, don't automatically retry to prevent loops
        if (video.dataset.shouldPlay === 'true' && !video.dataset.userPaused) {
          console.log('Video paused unexpectedly, user can tap to resume');
        }
      };
      video.addEventListener('pause', handlePause);
      cleanupFunctions.push(() => video.removeEventListener('pause', handlePause));

      // Play handler
      const handlePlay = () => {
        video.dataset.shouldPlay = 'true';
        video.dataset.userPaused = 'false';
        this.playAttempts.delete(video);
      };
      video.addEventListener('play', handlePlay);
      cleanupFunctions.push(() => video.removeEventListener('play', handlePlay));

      // Set up click/touch to pause functionality
      if (video.dataset.clickToPause === 'true') {
        this.setupClickToPause(video);
      }
    }

    // Simplified retry logic - no global event listeners
    setupPlayRetry(video: HTMLVideoElement) {
      const attempts = this.playAttempts.get(video) || 0;
      
      if (attempts >= this.MAX_PLAY_ATTEMPTS) {
        console.log('Max play attempts reached for video, stopping retries');
        return;
      }

      // Simple timeout-based retry instead of global event listeners
      setTimeout(() => {
        try {
          this.playVideo(video);
        } catch (error) {
          console.warn('Video retry failed:', error);
        }
      }, 1000);
    }

    setupIntersectionObserver() {
      const videos = document.querySelectorAll('.optimized-video[data-video-src]');
      
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const video = entry.target as HTMLVideoElement;
          
          if (entry.isIntersecting) {
            this.playVideo(video);
          } else {
            if (!video.paused) {
              video.pause();
              video.dataset.shouldPlay = 'false';
            }
          }
        });
      }, {
        rootMargin: '100px 0px',
        threshold: 0.25
      });

      videos.forEach(video => this.observer?.observe(video));
    }

    setupNetworkAwareLoading() {
      // Check for slow connections
      const connection = (navigator as any).connection;
      if (connection) {
        const isSlowConnection = connection.effectiveType === 'slow-2g' || 
                                connection.effectiveType === '2g' ||
                                connection.saveData;
        
        if (isSlowConnection) {
          // Disable autoplay on slow connections
          document.querySelectorAll('.optimized-video').forEach(video => {
            (video as HTMLVideoElement).autoplay = false;
            (video as HTMLVideoElement).preload = 'none';
          });
        }
      }
    }

    setupClickToPause(video: HTMLVideoElement) {
      const container = video.closest('.video-container') as HTMLElement;
      if (!container) return;

      const cleanupFunctions = this.eventCleanupFunctions.get(video) || [];

      // Add visual indicator that video is clickable
      container.style.cursor = 'pointer';
      container.setAttribute('title', 'Click to pause/play video');

      // Handle click events (desktop)
      const handleClick = (e: Event) => {
        e.preventDefault();
        e.stopPropagation();

        try {
          if (video.paused) {
            video.dataset.userPaused = 'false';
            this.playVideo(video);
          } else {
            video.dataset.userPaused = 'true';
            video.pause();
          }
        } catch (error) {
          console.warn('Video play/pause failed:', error);
        }
      };

      // Separate touch handling to avoid conflicts with swipe navigation
      const handleTouch = (e: TouchEvent) => {
        // Only handle single-finger taps directly on video
        if (e.touches.length > 1 || e.changedTouches.length > 1) {
          return; // Ignore multi-touch gestures
        }

        // Check if touch is directly on video element
        const target = e.target as Element;
        if (target !== video && !video.contains(target)) {
          return; // Ignore touches outside video
        }

        e.preventDefault();
        e.stopPropagation();

        try {
          if (video.paused) {
            video.dataset.userPaused = 'false';
            this.playVideo(video);
          } else {
            video.dataset.userPaused = 'true';
            video.pause();
          }
        } catch (error) {
          console.warn('Video play/pause failed:', error);
        }
      };

      // Add event listeners with cleanup tracking
      container.addEventListener('click', handleClick);
      cleanupFunctions.push(() => container.removeEventListener('click', handleClick));

      // Use touchstart instead of touchend to avoid conflicts with swipe detection
      container.addEventListener('touchstart', handleTouch, { passive: false });
      cleanupFunctions.push(() => container.removeEventListener('touchstart', handleTouch));

      // Keyboard accessibility
      container.setAttribute('tabindex', '0');
      container.setAttribute('role', 'button');
      container.setAttribute('aria-label', 'Play/pause video');

      const handleKeydown = (e: KeyboardEvent) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          handleClick(e);
        }
      };

      container.addEventListener('keydown', handleKeydown);
      cleanupFunctions.push(() => container.removeEventListener('keydown', handleKeydown));
    }

    setupReducedMotionSupport() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      
      const handleMotionPreference = (e: MediaQueryListEvent | MediaQueryList) => {
        if (e.matches) {
          const videos = document.querySelectorAll('.optimized-video');
          videos.forEach(video => {
            const videoElement = video as HTMLVideoElement;
            videoElement.autoplay = false;
            videoElement.pause();
          });
        }
      };

      prefersReducedMotion.addEventListener('change', handleMotionPreference);
      handleMotionPreference(prefersReducedMotion);
    }

    async playVideo(video: HTMLVideoElement) {
      const attempts = this.playAttempts.get(video) || 0;
      
      // Check if we've exceeded max attempts
      if (attempts >= this.MAX_PLAY_ATTEMPTS) {
        console.log('Max play attempts reached, stopping video play attempts');
        return;
      }

      this.playAttempts.set(video, attempts + 1);
      video.dataset.shouldPlay = 'true';

      // Ensure iOS attributes are set (belt and suspenders)
      video.muted = true;
      video.playsInline = true;
      video.setAttribute('muted', '');
      video.setAttribute('playsinline', '');

      const src = video.dataset.videoSrc;
      if (src && video.currentSrc === '') {
        try {
          video.load();
        } catch (error) {
          console.warn('Video load failed:', error);
          return;
        }
      }
      
      try {
        const playPromise = video.play();
        if (playPromise !== undefined) {
          await playPromise;
          video.classList.remove('loading');
          video.classList.add('loaded');
          console.log('Video playing successfully');
        }
      } catch (error: any) {
        console.warn(`Video autoplay prevented (attempt ${attempts + 1}):`, error.message);
        
        // Only retry if we haven't exceeded max attempts
        if (attempts < this.MAX_PLAY_ATTEMPTS - 1) {
          this.setupPlayRetry(video);
        }
      }
    }

    destroy() {
      // Clean up intersection observer
      if (this.observer) {
        this.observer.disconnect();
        this.observer = null;
      }

      // Clean up all event listeners
      this.eventCleanupFunctions.forEach((cleanupFunctions, video) => {
        cleanupFunctions.forEach(cleanup => {
          try {
            cleanup();
          } catch (error) {
            console.warn('Error during event cleanup:', error);
          }
        });
      });

      // Clear all maps
      this.playAttempts.clear();
      this.eventCleanupFunctions.clear();
    }
  }

  // Initialize when DOM is ready
  let videoManager: OptimizedVideo | null = null;

  function initVideoManager() {
    if (videoManager) {
      videoManager.destroy();
    }
    videoManager = new OptimizedVideo();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVideoManager);
  } else {
    initVideoManager();
  }

  // Re-initialize on page navigation
  document.addEventListener('astro:page-load', initVideoManager);

  // Cleanup
  window.addEventListener('beforeunload', () => {
    if (videoManager) {
      videoManager.destroy();
    }
  });
</script>

<style>
  .video-container {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .video-container[style*="cursor: pointer"] {
    transition: opacity var(--transition-normal, 0.3s ease);
  }

  .video-container[style*="cursor: pointer"]:hover {
    opacity: 0.9;
  }

  .video-container[style*="cursor: pointer"]:focus {
    outline: 2px solid var(--color-primary, #007acc);
    outline-offset: 2px;
  }

  .optimized-video {
    width: 100%;
    height: auto;
    display: block;
    background-color: var(--color-background-secondary, #f5f5f5);
    transition: opacity var(--transition-normal, 0.3s ease);
  }

  .optimized-video.loading {
    opacity: 0.7;
  }

  .optimized-video.loaded {
    opacity: 1;
  }

  .optimized-video.error {
    opacity: 0.5;
    filter: grayscale(1);
  }

  .video-fallback {
    padding: var(--spacing-md, 1rem);
    text-align: center;
    background-color: var(--color-background-secondary, #f5f5f5);
    border-radius: var(--rounded-sm, 4px);
    color: var(--color-text-secondary, #666);
  }

  .video-fallback a {
    color: var(--color-primary, #007acc);
    text-decoration: underline;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Respect user's motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .optimized-video {
      animation: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .video-container {
      border: 2px solid ButtonText;
    }
  }
</style>
