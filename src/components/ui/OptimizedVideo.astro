---
export interface VideoSources {
  mp4: string;
  webm?: string;
}

interface Props {
  sources: VideoSources;
  poster?: string;
  alt: string;
  width?: number;
  height?: number;
  class?: string;
}

const { sources, poster, alt, width, height, class: className } = Astro.props;
---

<div class={`video-container ${className || ''}`}>
  <video
    class="optimized-video"
    width={width}
    height={height}
    poster={poster}
    muted
    autoplay
    loop
    playsinline
    preload="metadata"
    aria-label={alt}
    data-video-src={sources.mp4}
  >
    {sources.webm && <source src={sources.webm} type="video/webm" />}
    <source src={sources.mp4} type="video/mp4" />
    <!-- Fallback for browsers that don't support video -->
    <p class="video-fallback">
      Your browser doesn't support video playback. 
      <a href={sources.mp4} download>Download the video</a> to view it.
    </p>
  </video>
  
  <!-- Screen reader description -->
  <span class="sr-only">{alt}</span>
</div>

<script>
  class OptimizedVideo {
    private observer: IntersectionObserver | null = null;
    private playAttempts: Map<HTMLVideoElement, number> = new Map();
    private readonly MAX_PLAY_ATTEMPTS = 3;

    constructor() {
      this.setupIntersectionObserver();
      this.setupNetworkAwareLoading();
      this.setupReducedMotionSupport();
      this.initializeVideos();
    }

    initializeVideos() {
      const videos = document.querySelectorAll('.optimized-video[data-video-src]');
      
      videos.forEach(videoEl => {
        const video = videoEl as HTMLVideoElement;
        
        // CRITICAL: Set iOS-required attributes via both property AND attribute
        video.muted = true;
        video.playsInline = true;
        video.setAttribute('muted', '');
        video.setAttribute('playsinline', '');
        
        // Set up event listeners
        this.setupVideoEventListeners(video);
        
        // Attempt immediate play for above-the-fold videos
        setTimeout(() => this.playVideo(video), 100);
      });
    }

    setupVideoEventListeners(video: HTMLVideoElement) {
      video.addEventListener('loadstart', () => {
        video.classList.add('loading');
      });

      video.addEventListener('loadeddata', () => {
        video.classList.remove('loading');
        video.classList.add('loaded');
      });

      video.addEventListener('error', () => {
        video.classList.add('error');
        console.warn('Video failed to load:', video.dataset.videoSrc);
      });

      video.addEventListener('playing', () => {
        video.classList.remove('loading');
        video.classList.add('loaded');
      });

      // iOS-specific: Handle unexpected pauses
      video.addEventListener('pause', () => {
        if (video.dataset.shouldPlay === 'true') {
          this.setupPlayRetry(video);
        }
      });

      video.addEventListener('play', () => {
        video.dataset.shouldPlay = 'true';
        this.playAttempts.delete(video);
      });
    }

    setupPlayRetry(video: HTMLVideoElement) {
      const attempts = this.playAttempts.get(video) || 0;
      
      if (attempts >= this.MAX_PLAY_ATTEMPTS) {
        return;
      }

      const retryPlay = () => {
        this.playVideo(video);
        document.removeEventListener('touchstart', retryPlay);
        document.removeEventListener('click', retryPlay);
        document.removeEventListener('scroll', retryPlay);
      };
      
      document.addEventListener('touchstart', retryPlay, { once: true, passive: true });
      document.addEventListener('click', retryPlay, { once: true });
      document.addEventListener('scroll', retryPlay, { once: true, passive: true });
    }

    setupIntersectionObserver() {
      const videos = document.querySelectorAll('.optimized-video[data-video-src]');
      
      this.observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const video = entry.target as HTMLVideoElement;
          
          if (entry.isIntersecting) {
            this.playVideo(video);
          } else {
            if (!video.paused) {
              video.pause();
              video.dataset.shouldPlay = 'false';
            }
          }
        });
      }, {
        rootMargin: '100px 0px',
        threshold: 0.25
      });

      videos.forEach(video => this.observer?.observe(video));
    }

    setupNetworkAwareLoading() {
      // Check for slow connections
      const connection = (navigator as any).connection;
      if (connection) {
        const isSlowConnection = connection.effectiveType === 'slow-2g' || 
                                connection.effectiveType === '2g' ||
                                connection.saveData;
        
        if (isSlowConnection) {
          // Disable autoplay on slow connections
          document.querySelectorAll('.optimized-video').forEach(video => {
            (video as HTMLVideoElement).autoplay = false;
            (video as HTMLVideoElement).preload = 'none';
          });
        }
      }
    }

    setupReducedMotionSupport() {
      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');
      
      const handleMotionPreference = (e: MediaQueryListEvent | MediaQueryList) => {
        if (e.matches) {
          const videos = document.querySelectorAll('.optimized-video');
          videos.forEach(video => {
            const videoElement = video as HTMLVideoElement;
            videoElement.autoplay = false;
            videoElement.pause();
          });
        }
      };

      prefersReducedMotion.addEventListener('change', handleMotionPreference);
      handleMotionPreference(prefersReducedMotion);
    }

    async playVideo(video: HTMLVideoElement) {
      const attempts = this.playAttempts.get(video) || 0;
      this.playAttempts.set(video, attempts + 1);

      video.dataset.shouldPlay = 'true';

      // Ensure iOS attributes are set (belt and suspenders)
      video.muted = true;
      video.playsInline = true;
      video.setAttribute('muted', '');
      video.setAttribute('playsinline', '');

      const src = video.dataset.videoSrc;
      if (src && video.currentSrc === '') {
        video.load();
      }
      
      try {
        const playPromise = video.play();
        if (playPromise !== undefined) {
          await playPromise;
          video.classList.remove('loading');
          video.classList.add('loaded');
        }
      } catch (error: any) {
        console.warn("Video autoplay prevented:", error.message);
        this.setupPlayRetry(video);
      }
    }

    destroy() {
      if (this.observer) {
        this.observer.disconnect();
      }
      this.playAttempts.clear();
    }
  }

  // Initialize when DOM is ready
  let videoManager: OptimizedVideo | null = null;

  function initVideoManager() {
    if (videoManager) {
      videoManager.destroy();
    }
    videoManager = new OptimizedVideo();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initVideoManager);
  } else {
    initVideoManager();
  }

  // Re-initialize on page navigation
  document.addEventListener('astro:page-load', initVideoManager);

  // Cleanup
  window.addEventListener('beforeunload', () => {
    if (videoManager) {
      videoManager.destroy();
    }
  });
</script>

<style>
  .video-container {
    position: relative;
    width: 100%;
    overflow: hidden;
  }

  .optimized-video {
    width: 100%;
    height: auto;
    display: block;
    background-color: var(--color-background-secondary, #f5f5f5);
    transition: opacity var(--transition-normal, 0.3s ease);
  }

  .optimized-video.loading {
    opacity: 0.7;
  }

  .optimized-video.loaded {
    opacity: 1;
  }

  .optimized-video.error {
    opacity: 0.5;
    filter: grayscale(1);
  }

  .video-fallback {
    padding: var(--spacing-md, 1rem);
    text-align: center;
    background-color: var(--color-background-secondary, #f5f5f5);
    border-radius: var(--rounded-sm, 4px);
    color: var(--color-text-secondary, #666);
  }

  .video-fallback a {
    color: var(--color-primary, #007acc);
    text-decoration: underline;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  /* Respect user's motion preferences */
  @media (prefers-reduced-motion: reduce) {
    .optimized-video {
      animation: none;
    }
  }

  /* High contrast mode support */
  @media (prefers-contrast: high) {
    .video-container {
      border: 2px solid ButtonText;
    }
  }
</style>
